-------------------------------------------------------------------------------
-- class 

function string.endswith(s, sub_str)
    local s = string.sub(s, -#sub_str)
    return s == sub_str
end

local _class = {}

local function class(name)
    local clazz = {__cname = name}
    _class[name] = clazz
    clazz.new = function(...)
        local instance = {}
        setmetatable(instance, {__index = clazz})
        if clazz.ctor then
            clazz.ctor(instance, ...)
        end
        return instance
    end
    return clazz
end

-- ninja syntax writer
local writer = class("writer")

function writer:ctor(output)
    self.output = output
end

function writer:comment(c)
    self.output:write("#  " .. c .. "\n")
end

function writer:newline() 
    self.output:write("\n")
end

function writer:variable(key, value, indent)
    self:line(string.format("%s = %s", key, value), indent)
end

function writer:rule(name, command, description)
    self:line("rule " .. name)
    self:variable("command", command, 1)
    if description ~= nil then
        self:variable("description", description, 1)
    end
end

function writer:build(output, rule, input)
    self:line(string.format("build %s: %s %s", output, rule, input))
end

function writer:line(text, indent)
    if indent == nil then
        indent = 0
    end
    local leading_space = string.rep("  ", indent)
    self.output:write(leading_space .. text .. '\n')
end

function writer:close()
    self.output:close()
end

local function main()
    -- declare target
    local target = {}
    target.name = "llab"

    target.sources = {
        "src/llab.rc",
        "src/llab.c",
        "src/ll_driver.c",
        "src/ll_engine.c",
        "src/ll_client.c"
    }

    -- gen build.ninja
    local f = io.open("./out/build.ninja", "w")
    local bn = writer.new(f)
    bn:comment("This file is used to build llab.")
    bn:comment("It is generated by configure.lua.")
    bn:newline()
    bn:variable("ninja_required_version", "1.10")
    bn:newline()

    local rules = {}
    table.insert(rules, { 
        name = "cc",
        command = "gcc ${defines} ${include_dirs} ${cflags} -c ${in} -o ${out}",
        description = "CC ${out}"
    })
    table.insert(rules, {
        name = "link",
        command = "gcc ${libs_dirs} ${libs} -o ${out} ${in}",
        description = "LINK ${out}"
    })
    table.insert(rules, {
        name = "rc",
        command = "windres -i ${in} -o ${out}",
        description = "RC ${out}"
    })

    for _, rule in ipairs(rules) do
        bn:rule(rule.name, rule.command, rule.description)
    end

    bn:newline()
    
    -- attributes
    bn:variable("cflags", "-g -O2 -Wall")
    bn:variable('defines', "-DUNICODE")
    bn:variable('include_dirs', "")
    bn:newline()

    -- attributes
    local deps = {}
    for _, source in ipairs(target.sources) do
        local outname = ""
        if string.endswith(source, '.c') then
            outname = string.sub(source, 1, -3) .. ".o"
            table.insert(deps, outname)
            bn:build(outname, "cc", "../" .. source)
        elseif string.endswith(source, '.rc') then
            outname = source .. ".o"
            table.insert(deps, outname)
            bn:build(outname, "rc", "../" .. source)
        end
    end

    bn:newline()

    local tn = target.name .. ".exe"
    bn:build(tn, "link", table.concat(deps, " "))

    bn:close()

end

main()